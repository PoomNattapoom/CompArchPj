lw          0           1           mpcand      # Load multiplicand into $1
        lw          0           2           mplier      # Load multiplier into $2
        lw          0           3           result      # Initialize result (0) into $3
        lw          0           7           stackP      # Initialize stack pointer
        lw          0           6           neg1        # Load -1 into $6 (used for decrementing stack pointer)
        lw          0           5           multAd      # Prepare to call multiply subroutine
        jalr        5           6                        # Call multiply function
        halt                                             # End of program
multpl  sw          7           6           0            # Save return address on stack
        add         7           7           6            # Decrement stack pointer using $6 (which contains -1)
        sw          7           1           0            # Save $1 (multiplicand) on stack
        add         7           7           6            # Decrement stack pointer using $6
        sw          7           2           0            # Save $2 (multiplier) on stack
        add         7           7           6            # Decrement stack pointer using $6
multlp  nand        4           2           1            # Calculate NAND of multiplier and 1
        nand        4           4           4            # NAND result with itself (equivalent to AND)
        beq         4           0           skpadd       # If LSB is 0, skip addition
        add         3           3           1            # Add multiplicand to result
skpadd add         1           1            1            # Double multiplicand (shift left by adding itself)
        lw          0           4           neg1         # Load neg1 into register for subtraction
        add         2           2           4            # Decrement multiplier (simulate shift right) 
        beq         2           0           done         # If multiplier == 0, end loop
        beq         0           0           multlp       # Continue loop (equivalent to unconditional jump)
done    lw          7           2           0            # Restore $2 (multiplier) from stack
        add         7           7           6            # Increment stack pointer
        lw          7           1           0            # Restore $1 (multiplicand) from stack
        add         7           7           6            # Increment stack pointer
        lw          7           6           0            # Restore return address from stack
        jalr        6           0                        # Return from subroutine
mpcand     .fill        7          # Example multiplicand = 7
mplier     .fill        3          # Example multiplier = 3
result     .fill        0          # Initialize result to 0
neg1       .fill        -1         # For decrementing the multiplier
stackP     .fill        0          # Stack start (initially empty)
multAd     .fill        multpl     # Address of multiply subroutine