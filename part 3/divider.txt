
        lw          0           1           dvd     # Load dividend into $1
        lw          0           2           dvs       # Load divisor into $2
        lw          0           3           quot      # Initialize quotient (0) into $3
        lw          0           4           remain     # Initialize remainder (0) into $4
        lw          0           7           stack         # Initialize stack pointer
        lw          0           5           dvAd     # Prepare to call divide subroutine
        jalr        5           6                        # Call divide function
        
        # Call done function after division
        lw          0           5           doneAd       # Prepare to call done function
        jalr        5           0                        # Call done function

divide:
        sw          7           6           stack         # Save return address on stack
        add         7           1           7             # Increment stack pointer
        sw          7           1           stack         # Save $1 (dividend) on stack
        add         7           1           7             # Increment stack pointer
        sw          7           2           stack         # Save $2 (divisor) on stack
        add         7           1           7             # Increment stack pointer
        sw          7           3           stack         # Save $3 (quotient) on stack
        add         7           1           7             # Increment stack pointer
        sw          7           4           stack         # Save $4 (remainder) on stack
        add         7           1           7             # Increment stack pointer

dvsloop:
        beq         1           0           done          # If dividend == 0, go to done
        beq         2           0           halcall     # If divisor == 0, call halt (error)

        beq         1           2           quotad  # If dividend == divisor, quotient is 1
        lw          0           6           neg1          # Load neg1 into $6
        add         1           6           1             # Subtract divisor from dividend
        add         3           3           5             # Increment quotient
        beq         0           0          dvsloop # Continue loop

quotad:
        add         3           3           4            # Increment quotient
        beq         0           0           done         # Jump to done

halcall:
        lw          0           5           haltAd      # Load address of halt subroutine into $5
        jalr        5           0                        # Jump to halt

done:
        lw          7           4           stack         # Restore $4 (remainder) from stack
        lw          7           3           stack         # Restore $3 (quotient) from stack
        lw          7           2           stack         # Restore $2 (divisor) from stack
        lw          7           1           stack         # Restore $1 (dividend) from stack
        lw          7           6           stack         # Restore return address from stack
        jalr        6           0                        # Return from subroutine

hlabel:
        halt                                          # Stop execution

dvd    .fill    1234       # Dividend (the number to be divided)
dvs    .fill    123        # Divisor (the number to divide by)
quot    .fill    0          # Initialize quotient (result of division)
remain   .fill    0          # Initialize remainder
neg1        .fill    -1         # Constant for -1 (used for subtraction or decrement)
dvst    .fill    divide     # Address of the division routine
stack       .fill    0          # Stack pointer (if needed for subroutine calls)
haltAd     .fill    hlabel  # Address of halt subroutine
doneAd     .fill    done       # Address of done function
dvAd   .fill    divide     # Address of divide subroutine
